#!/bin/bash
#
# Copyright (C) 2025  David Valin dvalin@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

exit_rtc=0
base_results_file=""

usage()
{
	echo Usage: $1
	echo "  --fields <string>: Contains a list in the following format"
	echo "       name:type,name:type"
	echo "    Valid types are"
	echo "     n: field is a numeric value"
	echo "     s: field is a string of some sort"
	echo "     sm: field is a string and must match exactly the name"
	echo "  --header_lines <n>: How many lines of header do we we expect."
	echo "  --results_file <path>: The results file generated by the test"
	echo "  --base_results_file <path>:  The path to the expected results that we are"
	echo "     to compare to."
	exit $2
}

error_out()
{
	echo $4
	echo $3
	echo field index checking: $1
	echo field type: $2
	exit 1
}

validate_lines()
{
	#
	# Perform the comparison of what we expect, to what we have.
	#
	# Format of passed file is "regexp" "data string"
	#
	while IFS= read -r test_info
	do
		regexp=`echo "$test_info" |  cut  -f 1`
		string=`echo "$test_info" |  cut  -f 2`
		#
		# Check to see if the string matches the regular expression.
		#
		echo $string | grep -E -q "$regexp"
		if [[ $? -ne 0 ]]; then
			echo "Error: Field regex mismatch, $regexp we have $string"
			exit_rtc=1
		fi
	done < "$1"
}

ARGUMENT_LIST=(
	"fields"
	"header_lines"
	"results_file"
	"base_results_file"
)
NO_ARGUMENTS=(
	"usage"
)
# read arguments
opts=$(getopt \
  --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
  --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
  --name "$(basename "$0")" \
  --options "h" \
  -- "$@"
)

eval set --$opts

results_file=""
fields=""
header_lines=0

while [[ $# -gt 0 ]]; do
	case "$1" in
		--base_results_file)
			base_results_file=$2
			shift 2
		;;
		--fields)
			fields=`echo $2 | sed "s/ /_/g" | sed "s/,/ /g"`
			shift 2
		;;
		--header_lines)
			header_lines=$2
			shift 2
		;;
		--results_file)
			results_file=$2
			shift 2
		;;
		--usage)
			usage $0 0
		;;
		-h)
			usage $0 0
		;;
		--)
			break;
		;;
		*)
			echo "option not found ${1}"
			usage $0 1
		;;
	esac
done

meta_head=0
meta_test=0
header_line=""
field_location=""
separ=""
field_index=1
rm -f tmp_results compare_file
while IFS= read -r test_info
do
	if [ $meta_head -eq 0 ]; then
		#
		# Skip over meta head
		#
		if [[ $test_info == *"# Test general meta end"* ]]; then
			meta_head=1
		fi
		continue
	fi
	if [[ $test_info == *"Test meta data start"* ]] then
		#
		# Skip over the test meta data.
		#
		meta_test=1
		continue
	fi
	if [[ $meta_test -eq 1 ]]; then
		if [[ $test_info == *"Test meta data end*" ]] then
			meta_test=0
		fi
		continue
	fi
	echo $test_info >> tmp_results
done < "$results_file"
#
# Create the compare file  by pasting the base results (reg exp) against the tmp_results
# file which is minus all the meta documentation.
#
paste $base_results_file tmp_results > compare_file
validate_lines compare_file
rm compare_file
exit $exit_rtc
