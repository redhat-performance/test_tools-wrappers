#!/bin/bash
#
# Copyright (C) 2025  David Valin dvalin@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

exit_rtc=0
base_results_file=""
header=""
compare_file=`mktemp /tmp/validate_compare.XXXXX`
filter_file=`mktemp /tmp/validate_filter.XXXXX`
verification_base=`mktemp /tmp/validate_veri_base.XXXXX`
verify_template=`mktemp /tmp/validate_veri_temp.XXXXX`
test_results=`mktemp /tmp/validate_test_res.XXXXX`

usage()
{
	echo Usage: $1
	echo "  --header_lines <n>: How many lines of header do we we expect."
	echo "  --results_file <path>: The results file generated by the test"
	echo "  --base_results_file <path>:  The path to the expected results that we are"
	echo "     to compare to."
	echo File format
	echo "  Format of file is expected to be csv with ':' as field separators"
	echo "  Directives:"
	echo "    %_header: Next line is the header"
	echo "    %_passes: We have multiple passes of the test.  First column in the csv"
	echo "       file will be the pass number"
	echo "    %_multiples:  We have multiple lines of the data."
	echo "    %_grouping: The data will appear in groups."
	exit $2
}

error_out()
{
	echo $4
	echo $3
	echo field index checking: $1
	echo field type: $2
	exit 1
}

validate_lines()
{
	#
	# Perform the comparison of what we expect, to what we have.
	#
	# Format of passed file is "regexp" "data string"
	#
	while IFS= read -r test_info
	do
		regexp=`echo "$test_info" |  cut  -f 1`
		string=`echo "$test_info" |  cut  -f 2`
		if [[ $string == "" ]]; then
			continue
		fi
		#
		# Check to see if the string matches the regular expression.
		#
		echo "$string" | grep -E -q "$regexp"
		if [[ $? -ne 0 ]]; then
			echo "Error: Field regex mismatch, $regexp we have $string"
			exit_rtc=1
		fi
	done < "$1"
}

ARGUMENT_LIST=(
	"header_lines"
	"results_file"
	"base_results_file"
)
NO_ARGUMENTS=(
	"usage"
)
# read arguments
opts=$(getopt \
  --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
  --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
  --name "$(basename "$0")" \
  --options "h" \
  -- "$@"
)

eval set --$opts

results_file=""
header_lines=0

while [[ $# -gt 0 ]]; do
	case "$1" in
		--base_results_file)
			base_results_file=$2
			shift 2
		;;
		--header_lines)
			header_lines=$2
			shift 2
		;;
		--results_file)
			results_file=$2
			shift 2
		;;
		--usage)
			usage $0 0
		;;
		-h)
			usage $0 0
		;;
		--)
			break;
		;;
		*)
			echo "option not found ${1}"
			usage $0 1
		;;
	esac
done

meta_test=0
header_line=""
field_location=""
separ=""
field_index=1

#
# First create the verification base file.
#
iteration_test=0
lines_per_pass=0
multiple_entries=0
multiple_groups=0
multiple_search=""
header_next=0
grouping=0


grep -v "^# " $base_results_file | grep -v "^#$" > $filter_file
while IFS= read -r verif_info
do
	if [[ $header_next -eq 1 ]]; then
		echo $verif_info >> $verification_base
		header_next=0
		continue
	fi
	if [[ $verif_info == *"%_passes"* ]]; then
		iteration_test=1
		continue
	fi
	if [[ $verif_info == *"%_multiples"* ]]; then
		multiple_entries=1
		continue
	fi
	if [[ $verif_info == *"%_header"* ]]; then
		header_next=1
		continue
	fi
	if [[ $verif_info == *"%_grouping"* ]]; then
		grouping=1
		continue
	fi
	if [[ $multiple_entries -eq 1 ]] || [[ $grouping -eq 1 ]]; then
		echo $verif_info >> $verification_base
		continue
	fi
	if [[ $iteration_test -eq 1 ]]; then
		if  [[ $verif_info != *"iteration"* ]]; then
			let "lines_per_pass=$lines_per_pass+1"
			#
			# Iteration number will be added later.
			#
			output=`echo $verif_info | cut -d: -f2-`
			echo $output >> $verification_base
		else 
			header=$verif_info
		fi
	else
		echo $verif_info >> $verification_base
	fi
done < "$filter_file"

lines=0
iterations=1
header_processed=0

grep -q "Test general meta end" $results_file
meta_head=$?
while IFS= read -r test_info
do
	if [ $meta_head -eq 0 ]; then
		#
		# Skip over meta head
		#
		if [[ $test_info == *"# Test general meta end"* ]]; then
			meta_head=1
		fi
		continue
	fi

	if [[ $test_info == *"Test meta data start"* ]]; then
		#
		# Skip over the test meta data.
		#
		meta_test=1
		continue
	fi
	if [[ $meta_test -eq 1 ]]; then
		if [[ $test_info == *"Test meta data end"* ]]; then
			meta_test=0
		fi
		continue
	fi
	if [[ $iteration_test -eq 1 ]]; then
		base_results_file=$verify_template
		let "lines=$lines+1"
		if [[ $lines -eq $lines_per_pass ]]; then
			while IFS= read -r verf_info
			do
				if [[ $verf_info == *"iteration"* ]]; then
					continue
				else
					echo $iterations:$verf_info >> $verify_template
				fi
			done < $verification_base
			let "iterations=$iterations+1"
			lines=0
		fi 
	fi
	if [[ $grouping -eq 1 ]] && [[ $groups_done -eq 0 ]]; then
		groups_done=1
		field=`echo $test_info | cut -d: -f 1`
		inst_cnt=`grep "^${field}:" $results_file | wc -l`
		let "inst_cnt=$inst_cnt+1"
		for i in `seq 0 $inst_cnt`;do
			cat $verification_base >> $verify_template
		done
		base_results_file=$verify_template
	fi
	if [[ $multiple_entries -eq 1 ]]; then
		next_line_header=0
		base_results_file=$verify_template
		line=0
		while IFS= read -r verf_info
		do
			if [[  $line -eq 0 ]]; then
				if [[ $header_processed -eq 0 ]]; then
					echo "$verf_info" >> $verify_template
					header_processed=1
					break
				fi
				let "line=$line+1"
			else
				echo "$verf_info" >> $verify_template
			fi
		done < $verification_base
		header_processed=1
	fi
	echo $test_info >> $test_results
done < "$results_file"
if [[ $multiple_entries -eq 1 ]]; then
	mv $verify_template $verification_base
fi
#
# Create the compare file  by pasting the base results (reg exp) against the tmp_results
# file which is minus all the meta documentation.
#
paste $verification_base $test_results > $compare_file
validate_lines $compare_file
rm -f $compare_file $verification_base $verify_template $test_results $filter_file
if [[ $exit_rtc -ne 0 ]]; then
	echo Failed
else
	echo Ran
fi
exit $exit_rtc
