#!/bin/bash

usage()
{
	echo ${0}:
	echo "  --no_packages: value 0 install packages, value 1 do not.  Check is here"
	echo "    so the test wrappers do not have to constantly do the check."
	echo "  --packages: comma separated list of packages to install"
	echo "  --update: Update the system."
	echo "  --usage: This usage message."
	echo "  --pip_packages: comma separated list of pip modules to install"
	echo "  --no_pip_packages: value 0 installs pip packages, value 1 does not.  Same logic as --no_packages"
	echo "  --python_exec: path to python interpreter to install pip modules for (default \"python3\"), will require installation of relevant packages to install pip"
	echo "  --update_cache: Update package cache before install/updating packages, 1 (default) updates cache, 0 skips cache update"
	exit 1
}

exit_out()
{
	echo $1 > /dev/stderr
	exit $2
}

update=0
install_cmd=""
is_installed=""
packages=""
remove_packages=""
wrapper_config=""
pip_packages=""
python_exec="python3"
update_cache=1
cache_cmd=""
skip_pkg_install=0
skip_pip_pkg_install=0

base_dir=$(dirname $(realpath $0))
running_os=$($base_dir/detect_os)

update_system_cache() {
	if [[ "$update_cache" -eq 1 ]]; then
		$install_cmd $cache_cmd
	fi
	update_cache=0 # Prevent multiple cache updates
}

# Install System packages
# Args:
# - Comma separated list of packages, can also be space separated and work
install_system_pkgs() {
	packages=$1
	package_list=$(echo ${packages} | sed "s/,/ /g")
	
	# Skip package installs when asked to, or no packages are listed
	if [[ "$skip_pkg_install" -eq 1 ]] || [[ -z "$package_list" ]]; then
		return 0 # Nothing to do
	fi
	update_system_cache
	for package in $package_list; do
		$install_cmd install -y $package
		if [ $? -ne 0 ]; then
			 exit_out "$install_cmd install of $package failed" 1
		fi
	done
}

# Fetches dependencies from a wrapper JSON file
# Args:
# - Wrapper file path
# - os name (will lookup .dependencies.<os> within the JSON file)
#
# Returns:
# CSV list of packages from the relevant section of the JSON file
parse_json()
{
	json_file=$1
	platform=$2

	if ! command -v jq > /dev/null; then
		install_system_pkgs jq >&2 # Move stdout to stderr to avoid returning noisy package install
	fi

	jq_args="-r --arg platform $platform"
	is_empty=$(jq $jq_args '.dependencies | if has($platform) then "0" else 1 end' $json_file)
	if [[ "$is_empty" -eq 1 ]]; then
		return
	fi

	dep_type=$(jq $jq_args '.dependencies[$platform] | if type=="array" then "unversioned" else "versioned" end' $json_file 2> /dev/null)

	if [[ "$dep_type" == "unversioned" ]]; then
		packages=$(jq $jq_args ".dependencies.$platform | @csv" $json_file 2> /dev/null)
	elif [[ "$dep_type" == "versioned" ]]; then
		os_version=$($base_dir/detect_os --os-version)
		os_major_version=$($base_dir/detect_os --os-version --major-version)
		
		for version in $os_version $os_major_version "default"; do
			packages=$(jq $jq_args --arg version "$version" '.dependencies[$platform][$version] | @csv' $json_file 2> /dev/null)

			if [[ $? -eq 0 ]]; then
				break
			fi
		done
	fi

	if [[ $? -ne 0 ]]; then
		echo "WARN: Could not find dependency information for $platform in $json_file, this could be intended behavior" > /dev/stderr
	fi
	echo $packages | tr -d '"'
}

# Append packages to a CSV list variable
# Args:
# - Existing CSV package list
# - CSV list of packages to add
#
# Returns:
# Full list of packages via `echo`
append_packages()
{
	existing_pkgs=$1
	pkgs=$2

	if [[ -z "$existing_pkgs" ]]; then
		echo $pkgs
	elif [[ -z "$pkgs" ]]; then
		echo $existing_pkgs
	else
		echo "$pkgs,$existing_pkgs"
	fi
}

# Installs pip packages
# No args, no return
# Will exit_out if unable to install a pip package
install_pip_pkgs() {
	python_pip_flags="--quiet"
	if [[ $running_os == "ubuntu" ]]; then
		python_pip_flags="$python_pip_flags --break-system-packages"
	fi

	install_cmd="$python_exec -m pip install $python_pip_flags"
	for pip_pkg in $(echo $pip_packages | sed -e 's/,/ /g'); do
		$install_cmd $pip_pkg
		if [[ $? -ne 0 ]]; then
			exit_out "$install_cmd failed to install $pip_pkg" 1
		fi
	done
}

ARGUMENT_LIST=(
	"is_installed"
	"no_packages"
	"no_pip_packages"
	"update_cache"
	"packages"
	"remove_packages"
	"wrapper_config"
	"pip_packages"
	"python_exec"
)

NO_ARGUMENTS=(
	"update"
	"usage"
)


# read arguments
opts=$(getopt \
    --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
    --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
    --name "$(basename "$0")" \
    --options "h" \
    -- "$@"
)

eval set -- "$opts"

while [[ $# -gt 0 ]]; do
        case "$1" in
		--is_installed)
			is_installed=$2
			shift 2
		;;
		--no_packages)
			skip_pkg_install=$2
			shift 2
		;;
		--packages)
			packages=$(append_packages $packages $2)
			shift 2
		;;
		--pip_packages)
			pip_packages=$(append_packages $pip_packages $2)
			shift 2
		;;
		--no_pip_packages)
			skip_pip_pkg_install=$2
			shift 2
		;;
		--python_exec)
			python_exec=$2
			shift 2
		;;
		--remove_packages)
			remove_packages=$2
			shift 2
		;;
		--update)
			update=1
			shift 1
		;;
		--usage)
			usage $0
		;;
		--wrapper_config)
			wrapper_config=$2
			shift 2
		;;
		--update_cache)
			update_cache=$2
			shift 2
		;;
		-h)
			usage $0
		;;
		--)
			break
		;;
		*)
			echo option not found $1
			usage $0
		;;
	esac
done

install_cmd=""
case "$running_os" in
	"ubuntu")
		install_cmd="/bin/apt"
		cache_cmd="update"
	;;
	"sles")
		install_cmd="/usr/bin/zypper"
		cache_cmd="refresh"
	;;
	*)
		if [[ -f "/bin/dnf" ]]; then
			install_cmd="/bin/dnf"
		elif [[ -f "/bin/yum" ]]; then
			install_cmd="/bin/yum"
		fi
		cache_cmd="makecache"
	;;
esac

if [[ $install_cmd == "" ]]; then
	exit_out "package_install: Do not know what to use to install packages with" 1
fi

if [[ $is_installed != "" ]]; then
	$install_cmd list installed | grep -q $is_installed
	exit $?
fi

if [[ $remove_packages != "" ]]; then
	pkgs_rm=`echo $remove_packages | sed "s/,/ /g"`
	$install_cmd remove -y $pkg_rm
	if [ $? -ne 0 ]; then
		exit_out "Failed: Was unable to remove some or all of the package(s) $remove_packages" 1
	fi
fi

if [ $update -ne 0 ]; then
	$install_cmd update -y
	if [ $? -ne 0 ]; then
		exit_out "$install_cmd update failed" 1
	fi
fi

if [[ -n "$wrapper_config" ]]; then
	wrapper_pkgs=$(parse_json $wrapper_config $running_os)
	if [[ $? -ne 0 ]]; then
		exit_out "Error parsing .dependencies.$running_os in $wrapper_config" 1
	fi
	wrapper_pip=$(parse_json $wrapper_config pip)
	if [[ $? -ne 0 ]]; then
		exit_out "Error parsing .dependencies.pip in $wrapper_config" 1
	fi
	
	packages=$(append_packages $packages $wrapper_pkgs)
	pip_packages=$(append_packages $pip_packages $wrapper_pip)
fi

# Ensure pip is available for the default python3 interpreter.
# If a custom one is provided, let the wrapper figure out the
# correct method to install pip
if [[ -n "$pip_packages" ]] && [[ "$python_exec" == "python3" ]]; then
	pip_os_pkg=$(parse_json $base_dir/deps/python_pip.json $running_os)
	if [[ -z "$pip_os_pkg" ]]; then
		exit_out "$running_os has no known python3-pip package" 1
	fi
	packages=$(append_packages $packages $pip_os_pkg)
fi

install_system_pkgs "$packages"

if [[ "$skip_pip_pkg_install" -eq 0 ]] && [[ -n "$pip_packages" ]]; then
	install_pip_pkgs
fi
exit 0
