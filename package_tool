#!/bin/bash

usage()
{
	echo ${0}:
	echo "  --no_packages: value 0 install packages, value 1 do not.  Check is here"
	echo "    so the test wrappers do not have to constantly do the check."
	echo "  --packages: comma separated list of packages to install"
	echo "  --update: Update the system."
	echo "  --usage: This usage message."
	echo "  --pip_packages: comma separated list of pip modules to install"
	echo "  --python_exec: path to python intrepreter to install pip modules for (default \"python3\"), will require installation of relevant packages to install pip"
	exit 1
}

exit_out()
{
	echo $1
	exit $2
}

update=0
install_cmd=""
is_installed=""
packages=""
remove_packages=""
wrapper_config=""
pip_packages=""
python_exec="python3"

base_dir=$(dirname $(realpath $0))
running_os=$($base_dir/detect_os)

# Fetches dependencies from a wrapper JSON file
# Args:
# - Wrapper file path
# - os name (will lookup .dependencies.<os> within the JSON file)
#
# Returns:
# CSV list of packages from the relevant section of the JSON file
parse_json()
{
	json_file=$1
	platform=$2

	jq -r ".dependencies.$platform | @csv"  $json_file | tr -d '"'
}

# Append packages to a CSV list variable
# Args:
# - Existing CSV package list
# - CSV list of packages to add
#
# Returns:
# Full list of packages via `echo`
append_packages()
{
	existing_pkgs=$1
	pkgs=$2

	if [[ -z "$existing_pkgs" ]]; then
		echo $pkgs
	elif [[ -z "$pkgs" ]]; then
		echo $existing_pkgs
	else
		echo "$pkgs,$existing_pkgs"
	fi
}

# Installs pip packages
# No args, no return
# Will exit_out if unable to install a pip package
install_pip_pkgs() {
	python_pip_flags="--quiet"
	if [[ $running_os == "ubuntu" ]]; then
		python_pip_flags="$python_pip_flags --break-system-packages"
	fi

	install_cmd="$python_exec -m pip install $python_pip_flags"
	for pip_pkg in $(echo $pip_packages | sed -e 's/,/ /g'); do
		$install_cmd $pip_pkg
		if [[ $? -ne 0 ]]; then
			exit_out "$install_cmd failed to install $pip_pkg" 1
		fi
	done
}

ARGUMENT_LIST=(
	"is_installed"
	"no_packages"
	"packages"
	"remove_packages"
	"wrapper_config"
	"pip_packages"
	"python_exec"
)

NO_ARGUMENTS=(
	"update"
	"usage"
)


# read arguments
opts=$(getopt \
    --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
    --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
    --name "$(basename "$0")" \
    --options "h" \
    -- "$@"
)

eval set --$opts

while [[ $# -gt 0 ]]; do
        case "$1" in
		--is_installed)
			is_installed=$2
			shift 2
		;;
		--no_packages)
			if [[ $2 == "1" ]]; then
				exit 0
			fi
			shift 2
		;;
		--packages)
			packages=$(append_packages $packages $2)
			shift 2
		;;
		--pip_packages)
			pip_packages=$(append_packages $pip_packages $2)
			shift 2
		;;
		--python_exec)
			python_exec=$2
			shift 2
		;;
		--remove_packages)
			remove_packages=$2
			shift 2
		;;
		--update)
			update=1
			shift 1
		;;
		--usage)
			usage $0
		;;
		--wrapper_config)
			wrapper_config=$2
			shift 2
		;;
		-h)
			usage $0
		;;
		--)
			break
		;;
		*)
			echo option not found $1
			usage $0
		;;
	esac
done

install_cmd=""
case "$running_os" in
	"ubuntu")
		install_cmd="/bin/apt"
	;;
	"sles")
		install_cmd="/usr/bin/zypper"
	;;
	*)
		if [[ -f "/bin/dnf" ]]; then
			install_cmd="/bin/dnf"
		elif [[ -f "/bin/yum" ]]; then
			install_cmd="/bin/yum"
		fi
	;;
esac

if [[ $install_cmd == "" ]]; then
	exit_out "package_install: Do not know what to use to install packages with" 1
fi

if [[ $is_installed != "" ]]; then
	$install_cmd list installed | grep -q php-cli.x86_64
	exit $?
fi

if [[ $remove_packages != "" ]]; then
	pkgs_rm=`echo $remove_packages | sed "s/,/ /g"`
	$install_cmd remove -y $remove_packages
	if [ $? -ne 0 ]; then
		exit_out "Failed to remove $packages" 1
	fi
fi

if [ $update -ne 0 ]; then
	$install_cmd update -y
	if [ $? -ne 0 ]; then
		exit_out "$install_cmd update failed" 1
	fi
fi

if [[ -n "$wrapper_config" ]]; then
	wrapper_pkgs=$(parse_json $wrapper_config $running_os)
	wrapper_pip=$(parse_json $wrapper_config pip)
	
	packages=$(append_packages $packages $wrapper_pkgs)
	pip_packages=$(append_packages $pip_packages $wrapper_pip)
fi

# Ensure pip is available for the default python3 interpreter.
# If a custom one is provided, let the wrapper figure out the
# correct method to install pip
if [[ -n "$pip_packages" ]] && [[ "$python_exec" == "python3" ]]; then
	pip_os_pkg=$(parse_json $base_dir/deps/python_pip.json $running_os)
	if [[ -z "$pip_os_pkg" ]]; then
		exit_out "$running_os has no known python3-pip package" 1
	fi
	packages=$(append_packages $packages $pip_os_pkg)
fi

if [[ $packages != "" ]]; then
	package_list=`echo ${packages} | sed "s/,/ /g"`
	for package in $package_list; do
		$install_cmd install -y $package
		if [ $? -ne 0 ]; then
			 exit_out "$install_cmd install of $package failed" 1
		fi
	done
fi

if [[ -n "$pip_packages" ]]; then
	install_pip_pkgs
fi
exit 0
