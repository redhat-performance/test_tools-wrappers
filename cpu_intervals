#!/bin/bash

usage()
{
	echo "Usage: $1"
	echo "  --interval <x>: create x intervals (default is 4)."
	exit 0
}

#
# We will default to 4 intervals.
#
interval=4

ARGUMENT_LIST=(
        "interval"
)

NO_ARGUMENTS=(
        "usage"
)

# read arguments
opts=$(getopt \
    --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
    --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
    --name "$(basename "$0")" \
    --options "h" \
    -- "$@"
)

if [ $? -ne 0 ]; then
	exit 1
fi

eval set --$opts

while [[ $# -gt 0 ]]; do
	case "$1" in
		--interval)
			interval=$2
			shift 2
		;;
		--usage)
			usage $0
		;;
		-h)
			usage $0
		;;
		--)
			break;
		;;
		*)
			echo option not found $1
			usage $0
		;;
	esac
done

cpus=`nproc`
separ=","

#
# Make sure requested intervals is valid.
#
if [[ $interval -gt $cpus ]]; then
	echo Error, number of intervals may not exceed the number of cpus.
	exit 1
fi
if [[ $interval -eq 0 ]]; then
	echo Error, number of intervals may not be 0.
	exit 1
fi

#
# If only one interval requested, it is number of cpus.
# Else calculate the intervals.
#
if [[ $interval -ne 1 ]]; then
	stepping=`echo $cpus/$interval | bc`
	#
	# We want $interval, not $interval+1.  As we start from 1, not 
	# $stepping, we need to adjust.
	#
	max_seq=`echo "${interval}*${stepping}-${stepping}-1" | bc`
	cpu_oper=1
	for cpu in `seq $stepping $stepping $max_seq`
	do
		cpu_oper=${cpu_oper},${cpu}
	done
	cpu_oper=$cpu_oper$separ$cpus
else
	cpu_oper=$cpus
fi
echo $cpu_oper
exit 0
